# Redis持久化

  - Redis提供了2个不同形式的持久化方式:
    - RDB(Redis DataBase)
    - AOF(Append Of File)
    
## RDB

  - 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读到内存里。
  - RDB备份流程：
    - Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
    - 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。
    - 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
    - RDB的缺点是最后一次持久化后的数据可能丢失。
  - RDB默认保存文件是dump.rdb。
  - 触发RDB快照命令：
    - save: 只管保存，其它不管，全部阻塞。
    - bgsave: Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。
    - flushall: 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。
  - RDB的恢复：
    - 关闭Redis
    - 把备份的文件拷贝到工作目录下
    - 启动Redis, 备份数据会直接加载
  - RDB优点：
    - 适合大规模的数据恢复，恢复速度快。
    - 节省磁盘空间。
    - 如果对数据完整性和一致性要求不高，可以采用RDB。
  - RDB缺点：
    - 在备份周期在一定间隔时间做一次备份，如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。
    - 虽然Redis在fork时使用了写时拷贝技术，但是fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。
    
## AOF

  - 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件。
  - Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。
  - AOF默认保存文件是appendonly.aof。
  - AOF启动：
    - 修改配置文件默认的appendonly no，改为yes。
  - AOF的恢复：
    - 将有数据的aof文件复制一份保存到对应目录(config get dir)。
    - 重启Redis然后重新加载。
  - AOF损坏文件的修复：
    - redis-check-aof --fix进行修复。
  - AOF同步频率设置：
    - appendfsync always: 始终同步，每次Redis的写入都会立刻记入日志。
    - appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。
    - appendfsync no：从不同步。
  - 重写机制： 
    - AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制。
    - 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。
    - AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。
  - AOF优点：
    - 备份机制更稳健，丢失数据概率更低。
    - 数据的完整性和一致性更高。
  - AOF缺点：
    - 比起RDB占用更多的磁盘空间。
    - 恢复备份速度要慢。
  
## RDB和AOF对比

  - 官方推荐两个都启用。
  - 如果对数据不敏感，可以选单独用RDB。
  - 如果同时开启两种方式，当Redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
    
    
    
