# Redis事务

  - MULTI, EXEC, DISCARD and WATCH是Redis事务的基础
  - 可以一次执行多个命令，本质是一组命令的集合。有2个重要的保证：
    - 一个事务中的所有命令都会序列化，按顺序地串行化执行，可以保证这些命令作为一个独立的操作而执行
    - Redis事务是原子性的，或者全部命令执行成功，或者一个命令也不执行
  - Redis事务的主要作用就是串联多个命令防止别的命令插队，不许加塞。
  
## 事务的使用

  - 开启：从输入Multi命令开始事务。
  - 入队列：发出多个命令，这些命令并不会立即执行，而是放到等待执行的事务队列里面。
  - 执行：调用EXEC命令触发事务的执行。
  - Discard命令会清空事务队列，退出事务
  - 事务示例：
  
  ![事务示例](./图片/事务示例.PNG)
  
## 事务错误处理

  - 命令错误处理：
    - 在执行Exec命令之前，队列中某个命令出现了错误，例如语法错误（参数错误，命令名称错误等）
    - 客户端会检查queued命令返回结果，如果返回QUEUED则命令入队列成功，返回error则会丢弃这个事务操作
  
    ![命令错误处理](./图片/命令错误处理.PNG)
  
  - 执行错误处理：
    - 在执行Exec命令时，某个命令报出了错误
    - 只有报错的命令不会被执行，而其他的命令都会执行
  
    ![执行错误处理](./图片/执行错误处理.PNG)
  
  - Redis不支持回滚的原因：
    - Redis命令只是在语法错误时会失败，实际中是编程错误，这类错误应该在开发中发现，而不是在生产中发现。
    - 因为不用回滚，内部处理机制可以更简化和快速
  
## 事务相关概念

  - 悲观锁(Pessimistic Lock)：
    - 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。
    - 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁。
  - 乐观锁(Optimistic Lock)：
    - 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，使用版本号等机制。
    - 乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。
    
## 事务的监控(watch/unwatch)

  - watch: 
    - 在执行multi之前，先执行watch key1 [key2], 可以监视一个(或多个)key 
    - watch使用CAS机制监控事务，如果在事务执行之前这个(或这些)key被其他命令所改动，那么事务将被丢弃
    - 如果没有key被修改，则正常执行exec命令，exec命令执行之后所有被监控的key会解除监控状态
  - unwatch:
    - 取消watch命令对所有key的监视。
    - 如果在执行watch命令之后，exec命令或discard命令先被执行，那么就不需要再执行unwatch。
    
