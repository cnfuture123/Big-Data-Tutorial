# 泛型

## 泛型的概述

  - 集合容器类在声明阶段不能确定这个容器实际存的是什么类型的对象，JDK 1.5之后使用泛型，把元素的类型设计成一个参数，这个类型参数叫做泛型。
    ```
    例如：Collection<E>, List<E>
    ```
  - 泛型是参数化类型的概念，允许在创建集合时再指定集合元素的类型
  - 泛型的作用：
    - 解决元素存储的安全性问题，如果用Object类则任何类型都可以添加到集合中
    - 解决获取数据元素时，需要强制类型转换的问题，避免ClassCastException
  
## 自定义泛型

  - 泛型的声明：
    - interface List<T>
    - class Test<K, V>
  - 泛型的实例化：
    - 需要在类名后面指定类型参数的值
    - 例如：
      - List<String> strList = new ArrayList<String>();
      - Iterator<Customer> iterator = customers.iterator();
    - T只能是类，不能用基本数据类型填充，可以用包装类替换
  - 泛型的特点：
    - 泛型类可能有多个参数，应将多个参数一起放在尖括号内。例如：<E1, E2, E3>
    - 泛型不同的引用不能相互赋值
    - 泛型如果不指定将被擦除，泛型类型按照Object处理。
    - 静态方法中不能使用类的泛型
    - 异常类不能是泛型的
    - 不能new E[]
    - 如果B是A的子类型（子类或子接口），泛型的表示没有这种子类关系
  
## 使用通配符

  - 类型通配符：?
    - 例如：List<?>是List<String>, List<Object>等各种泛型List的父类
    - 读取List<?>的对象list中的元素是安全的，因为不管list的真实类型是什么，它包含的都是Object
    - 写入list元素不是类型安全的，因为不知道具体的元素类型，不能添加对象，会编译错误
      - 唯一的例外是null，它是所有类型的成员
  - 有限制的通配符：
    - 指定上限（? extends）：使用时指定的类型必须是继承某个类，或实现某个接口，即<=
      - 例如：<? extends Number> : 只允许泛型为Number及Number子类的引用调用
    - 指定下限（? super）：使用时指定的类型不能小于操作的类，即>=
      - 例如：<? super Number>：只允许泛型为Number及Number父类的引用调用

