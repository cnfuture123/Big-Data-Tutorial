## 高并发利器

  - 概述：缓存、限流、降级、熔断、隔离是高并发的5个利器

### 缓存

  - 概述：
    - 缓存分为本地缓存和分布式缓存两种：
      - 本地缓存：GuavaCache、Caffeine等
      - 分布式缓存：Redis、Memcached等
    - 缓存作用：
      - 提升软件响应速度
      - 解决数据库中查找速度慢的问题
    - 缓存三大特征：
      - 命中率：
        - 命中率 = 命中数 /（命中数+没有命中数）
        - 当某个请求能够通过访问缓存而得到响应时，称为缓存命中。缓存命中率越高，缓存的利用率也就越高
      - 最大空间：
        - 最大空间表示缓存中可以容纳最大的元素数量
        - 当缓存存放的数据超过最大空间时，就需要根据淘汰算法来淘汰部分数据存放新到达的数据
      - 淘汰算法：
        - FIFO（先进先出）：
          - 最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会优先被清除掉，以腾出新的空间接受新的数据
          - 比较的对象：缓存元素的创建时间
          - 业务场景：适用于保证高频数据有效性场景，优先保障最新数据可用
        - LFU(less frequently used)：最少使用
          - 仅根据元素的被使用次数判断，清除使用次数较少的元素释放空间
          - 比较的对象：元素的hitCount（命中次数）
          - 业务场景：适用于保证高频数据有效性场景
        - LRU(least recently used)：最近最少使用
          - 根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间
          - 比较的对象：元素最近一次被get使用时间
          - 业务场景：适用于热点数据场景，优先保证热点数据的有效性
  - 本地缓存（进程内缓存）：
    - 概述：
      - 定义：应用和缓存都在同一个进程里面
      - 优点：获取缓存数据的时候是纯内存操作，没有额外的网络开销，速度非常快
      - 缺点：
        - 本地缓存与业务系统耦合在一起，应用之间无法直接共享缓存的内容
        - 本地缓存机器重启、或者宕机数据都会丢失
        - 需要每个应用节点单独的维护自己的缓存。每个节点都需要一份一样的缓存，对服务器内存造成一种浪费
    - 本地缓存更新方式：
      - 定时变量更新：
        - 在应用中起一个定时任务，每隔一段时间去加载变更的数据到缓存里面；数据变更之后可以修改数据库最后修改的时间，每次查询变更数据的时候都可以根据最后变更时间加上半小时大于当前时间的数据
      - 定时全量更新：
        - 每隔一段时间去加载加载全部的数据到缓存，这种方式对数据更新可能会有延迟。可能这台机器看到的是更新后的数据，那台机器看到的数据还是老的（因为机器发布时间可能不一样）
      - 广播订阅队列消息：
        - 如果对实时性有要求的话，使用广播订阅mq消息更新
        - 一旦有数据更新mq会把更新数据推送到每一台机器，实时性好，但是实现起来较为复杂
  - 分布式缓存：
    - 定义：与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接共享缓存
  - 多级缓存：
    - 本地缓存+分布式缓存：本地缓存中只保存访问频率最高的部分热点数据，分布式缓存中保存其他的热点数据
  - 缓存存在的问题：
    - 缓存雪崩：
      - 定义：大量缓存同一时间段集体失效，或者缓存整体不能提供服务，导致大量的请求全部到达数据库，对数据CPU和内存造成巨大压力，严重的会造成数据库宕机
      - 解决方式：
        - 保证缓存的高可用，使用主从模式和集群模式来尽量保证缓存服务的高可用：
          - 使用Redis集群模式，即使个别redis节点下线，缓存还是可以用
          - 将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题，单个服务对应单个Redis分片
        - 使用多级缓存（本地缓存 + 分布式缓存，推荐方式）：
          - 不同级别的缓存过期时间不同，即使某个级别缓存过期了，还有其他级别的缓存兜底
        - 缓存永不过期：
          - 优点：缓存永不过期，就不会发生缓存雪崩
          - 缺点：会浪费更多的存储空间
          - 应用场景：电商首页或特别热门的页面，因为访问量太大，不能使这部分缓存失效，因此牺牲一点存储空间
        - 使用随机过期时间（推荐方式）：
          - 为每一个key都合理的设计一个过期时间（在缓存时使用固定时间加上一个小的随机数），这样可以避免大量的热点key在同一时刻集体失效
    - 缓存穿透:
      
  - 参考：
    - https://www.codenong.com/cs109117406/
    
        


    
