# Java锁

## 基本概念

  - 线程安全：
    - 当多个线程并发访问某个Java对象时，无论系统如何调度这些线程，无论这些线程如何交替操作，这个对象都能表现出一致的、正确的行为，那么对这个对象的操作是线程安全的
    - 自增运算符不是线程安全的，它是一个复合操作，至少包括3个JVM指令：内存取值，寄存器加1，存值到内存。两个或两个以上的原子操作合在一起进行操作就不具备原子性
  - 临界区资源：
    - 在并发情况下，临界区资源是受保护的对象
    - 临界区代码段是每个线程中访问临界资源的那段代码，多个线程必须互斥地对临界区资源进行访问
    - 可以使用synchronized关键字同步代码块，对临界区代码段进行排他性保护

## synchronized关键字

  - 每个Java对象都隐含有一把锁，称为Java内置锁（或对象锁）。使用synchronized(syncObject)调用获取syncObject的内置锁
  - synchronized方法是一种粗粒度的并发控制，某一时刻只能有一个线程执行该synchronized方法；而synchronized代码块是一种细粒度的并发控制，处于synchronized块之外的其他代码是可以被多个线程并发访问的。
  - synchronized方法实际等同于一个synchronized代码块，这个代码块包含同步方法中的所有语句，然后在synchronized代码块的括号中传入this关键字，使用this对象锁作为进入临界区的同步锁
  - 使用synchronized修饰static方法时，synchronized的同步锁不是普通的Object对象的监视锁，而是类对应的Class对象的监视锁

## 生产者-消费者问题

  - 生产者-消费者问题也称有限缓冲问题，关键是：
    - 保证生产者不会在缓冲区满时加入数据，消费者不会在缓冲区空时消费数据
    - 保证生产者加入数据，消费者消费数据过程中，不会产生错误的数据和行为

## Java对象锁结构

  - Java对象结构包括三部分：对象头、对象体和对齐字节
    - 对象头：
      - Mark Word(标记字)：用于存储自身运行时的数据，例如：GC标志位，哈希码，锁状态等
      - Class Pointer(类对象指针)：用于存放方法区Class对象的地址，JVM通过这个指针来确定这个对象是哪个类的实例
      - Array Length(数组长度)：如果对象是Java数组，此字段用于记录数组长度
    - 对象体：包含对象的实例变量
    - 对齐字节：用于保证Java对象所占内存字节数为8的倍数
  - Java内置锁：
    - 4种状态，级别由低到高依次为：无锁、偏向锁、轻量级锁和重量级锁，内置锁可以升级但不能降级
      - 无锁状态：没有任何线程竞争
      - 偏向锁状态：
        - 一段同步代码一直被同一个线程所访问，那么该线程自动获取锁，降低获取锁的代价。如果内置锁处于偏向锁状态，当有一个线程来竞争锁时，先用偏向锁，表示内置锁偏爱这个线程，这个线程要执行该锁关联的同步代码时，不需要再做任何检查和切换。偏向锁在竞争不激烈的情况下效率比较高
        - 当有两个线程竞争这个锁对象时，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象，锁对象的Mark Word就指向那个线程的栈帧中的锁记录。企图抢占的线程会通过自旋的形式尝试获取锁，不会阻塞抢锁线程。
        - 自旋原理：
          - 如果持有锁的线程在很短的时间内释放锁资源，等待竞争锁的线程就不需要进行内核态和用户态之间的切换进入阻塞挂起状态，只需要等一等（自旋），等待有锁的线程释放锁后即可获取锁。
          - 但是线程自旋是消耗CPU的，如果一直获取不到锁，那么线程就是一直占用CPU做无用功。JDK 1.6之后引入了适应性自旋锁，自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定相应地，如果自旋成功了，下次自旋的次数增加，反之次数减少。
          - 如果持有锁的线程执行时间超过自旋等待的最大时间仍没有释放锁，争用线程会停止自旋进入阻塞状态，该锁膨胀为重量级锁
    - 64位Mark Word结构：
      ![image](https://user-images.githubusercontent.com/46510621/145675162-8dd153e8-6a29-4665-9129-f9bba0056cce.png)
    - 锁状态标志位：
      ![image](https://user-images.githubusercontent.com/46510621/145675214-1c800366-dda1-4f89-a3d9-d4506acbda97.png)
  - 大小端问题：
    - 大端模式是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。所有网络协议都是采用大端模式传输数据
    - 小端模式是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。小端模式是处理器的主流字节存放方式，JVM采用这种方式存放字节

