# Java锁

## 基本概念

  - 线程安全：
    - 当多个线程并发访问某个Java对象时，无论系统如何调度这些线程，无论这些线程如何交替操作，这个对象都能表现出一致的、正确的行为，那么对这个对象的操作是线程安全的
    - 自增运算符不是线程安全的，它是一个复合操作，至少包括3个JVM指令：内存取值，寄存器加1，存值到内存。两个或两个以上的原子操作合在一起进行操作就不具备原子性
  - 临界区资源：
    - 在并发情况下，临界区资源是受保护的对象
    - 临界区代码段是每个线程中访问临界资源的那段代码，多个线程必须互斥地对临界区资源进行访问
    - 可以使用synchronized关键字同步代码块，对临界区代码段进行排他性保护

## synchronized关键字

  - 每个Java对象都隐含有一把锁，称为Java内置锁（或对象锁）。使用synchronized(syncObject)调用获取syncObject的内置锁
  - synchronized方法是一种粗粒度的并发控制，某一时刻只能有一个线程执行该synchronized方法；而synchronized代码块是一种细粒度的并发控制，处于synchronized块之外的其他代码是可以被多个线程并发访问的。
  - synchronized方法实际等同于一个synchronized代码块，这个代码块包含同步方法中的所有语句，然后在synchronized代码块的括号中传入this关键字，使用this对象锁作为进入临界区的同步锁
  - 使用synchronized修饰static方法时，synchronized的同步锁不是普通的Object对象的监视锁，而是类对应的Class对象的监视锁

## 生产者-消费者问题

  - 生产者-消费者问题也称有限缓冲问题，关键是：
    - 保证生产者不会在缓冲区满时加入数据，消费者不会在缓冲区空时消费数据
    - 保证生产者加入数据，消费者消费数据过程中，不会产生错误的数据和行为

## Java对象锁结构

  - Java对象结构包括三部分：对象头、对象体和对齐字节
    - 对象头：
      - Mark Word(标记字)：用于存储自身运行时的数据，例如：GC标志位，哈希码，锁状态等
      - Class Pointer(类对象指针)：用于存放方法区Class对象的地址，JVM通过这个指针来确定这个对象是哪个类的实例
      - Array Length(数组长度)：如果对象是Java数组，此字段用于记录数组长度
    - 对象体：包含对象的实例变量
    - 对齐字节：用于保证Java对象所占内存字节数为8的倍数
  - Java内置锁：
    - 4种状态，级别由低到高依次为：无锁、偏向锁、轻量级锁和重量级锁，内置锁可以升级但不能降级
      - 无锁：没有任何线程竞争
      - 偏向锁：
        - 一段同步代码一直被同一个线程所访问，那么该线程自动获取锁，降低获取锁的代价。如果内置锁处于偏向锁状态，当有一个线程来竞争锁时，先用偏向锁，表示内置锁偏爱这个线程，这个线程要执行该锁关联的同步代码时，不需要再做任何检查和切换。偏向锁在竞争不激烈的情况下效率比较高
        - 当有两个线程竞争这个锁对象时，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象，锁对象的Mark Word就指向那个线程的栈帧中的锁记录。企图抢占的线程会通过自旋的形式尝试获取锁，不会阻塞抢锁线程。
        - 自旋原理：
          - 如果持有锁的线程在很短的时间内释放锁资源，等待竞争锁的线程就不需要进行内核态和用户态之间的切换进入阻塞挂起状态，只需要等一等（自旋），等待有锁的线程释放锁后即可获取锁。
          - 但是线程自旋是消耗CPU的，如果一直获取不到锁，那么线程就是一直占用CPU做无用功。JDK 1.6之后引入了适应性自旋锁，自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定相应地，如果自旋成功了，下次自旋的次数增加，反之次数减少。
          - 如果持有锁的线程执行时间超过自旋等待的最大时间仍没有释放锁，争用线程会停止自旋进入阻塞状态，该锁膨胀为重量级锁
        - 偏向锁的缺点：如果锁对象经常被多个线程竞争，偏向锁就是多余的，并且撤销的过程有一些性能开销
        - 偏向锁加锁过程：新线程需要判断内置锁对象的Mark Word中的线程ID是否是自己的ID，如果是就直接使用这个锁；如果不是就使用CAS交换，新线程将自己的ID交换到内置锁的Mark Word中，如果交换成功就加索成功
      - 轻量级锁：
        - 引入轻量级锁的目的是在多线程竞争不激烈的情况下，通过CAS机制竞争减少重量级锁产生的性能损耗
        - 轻量级锁的执行过程：
          - JVM首先在抢锁线程的栈帧中建立一个锁记录(Lock Record)，用于存储对象目前的Mark Word
          - 抢锁线程使用CAS自旋操作，尝试将内置锁对象的Mark Word中的ptr_to_lock_record(锁记录指针)更新为抢锁线程栈帧中锁记录的地址，如果更新成功，这个线程就拥有了该锁
        - 轻量级锁主要有两种：普通自旋锁，自适应自旋锁
          - 普通自旋锁：当有线程来竞争锁时，抢锁线程原地循环等待，不会被阻塞，直到占用锁的线程释放锁之后，抢锁线程才可以获得锁。默认情况下自旋的次数是10 
          - 自适应自旋锁：等待线程的循环次数不是固定的，自旋次数由上一次在同一个锁的自旋时间以及锁的拥有者的状态决定
        - 在竞争激烈的情况下，轻量级锁会膨胀为基于操作系统互斥锁实现的重量级锁
      - 重量级锁：
        - JVM中每个对象会有一个监视器，监视器和对象一起创建和销毁。监视器的作用是保证同一时间只有一个线程可以访问被保护的临界区代码块
        - 在Hotspot虚拟机中，监视器由ObjectMonitor实现，包含WaitSet、Cxq、EntryList三个队列：
          - Cxq: 竞争队列，所有请求锁的线程首先被放在这个队列中
          - EntryList: Cxq中有资格成为候选资源的线程被移动到EntryList中
          - WaitSet: 某个拥有ObjectMonitor的线程调用Object.wait()方法后将被阻塞，然后被放到这个队列
        - 进程从用户态到内核态切换的三种方式：硬件中断，系统调用，异常
    - 64位Mark Word结构：
      ![image](https://user-images.githubusercontent.com/46510621/145675162-8dd153e8-6a29-4665-9129-f9bba0056cce.png)
    - 锁状态标志位：
      ![image](https://user-images.githubusercontent.com/46510621/145675214-1c800366-dda1-4f89-a3d9-d4506acbda97.png)
  - 大小端问题：
    - 大端模式是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。所有网络协议都是采用大端模式传输数据
    - 小端模式是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。小端模式是处理器的主流字节存放方式，JVM采用这种方式存放字节

## CAS

  - 操作系统层面的CAS是一条CPU的原子指令（cmpxchg指令）
  - Unsafe提供的CAS方法包含4个操作数：字段所在的对象、字段内存位置、预期原值和新值。在执行Unsafe的CAS方法时，首先将内存位置的值与预期值比较，如果相匹配则CPU会自动将内存位置的值更新为新值，并返回true，否则不做任何操作并返回false
  - 使用CAS进行无锁编程的步骤是：
    - 获得字段的预期值
    - 计算出需要替换的新值
    - 通过CAS将新值放在字段的内存地址上，如果CAS失败就重复以上两步，直到CAS成功，也称为CAS自旋

## JUC原子类

  - JUC原子类分为4类：基本原子类、数组原子类、原子引用类和字段更新原子类
    - 基本原子类：
      - AtomicInteger: 整型原子类
      - AtomicLong: 长整型原子类
      - AtomicBoolean: 布尔型原子类
      - 通过CAS自旋 + volatile实现线程安全，CAS用于保障变量操作的原子性，volatile用于保证变量的可见性
    - 数组原子类：
      - AtomicIntegerArray: 整型数组原子类
      - AtomicLongArray: 长整型数组原子类
      - AtomicReferenceArray: 引用类型数组原子类
    - 引用原子类：
      - AtomicReference: 引用类型原子类
        - 如果需要同时保障对多个变量操作的原子性，可以把多个变量放在一个对象中进行操作
      - AtomicMarkableReference: 带有更新标记位的原子引用类型
      - AtomicStampedReference: 带有更新版本号的原子引用类型
    - 字段更新原子类：
      - AtomicIntegerFieldUpdater: 原子更新整型字段的更新器
      - AtomicLongFieldUpdater: 原子更新长整型字段的更新器
      - AtomicReferenceFieldUpdater: 原子更新引用类型字段的更新器
  - ABA问题：
    - 乐观锁的实现版本使用版本号解决ABA问题。乐观锁每次在执行数据的修改操作时都会带上一个版本号，版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则执行失败
    - AtomicStampedReference在CAS的基础上增加了一个Stamp，使用这个时间戳判断数据是否发生变化，进行实效性检验
    - AtomicMarkableReference只关心是否修改过，其标记属性mark是boolean类型，记录值是否修改过
  - LongAdder: 以空间换时间的方式提升高并发场景下CAS操作的性能
    - LongAdder的核心思想是热点分离，将value值分离成一个数组，当多线程访问时，通过Hash算法将线程映射到数组的一个元素进行操作，而获得最终的value结果时，则将数组的元素求和


