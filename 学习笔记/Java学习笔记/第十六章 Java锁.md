# Java锁

## 基本概念

  - 线程安全：
    - 当多个线程并发访问某个Java对象时，无论系统如何调度这些线程，无论这些线程如何交替操作，这个对象都能表现出一致的、正确的行为，那么对这个对象的操作是线程安全的
    - 自增运算符不是线程安全的，它是一个复合操作，至少包括3个JVM指令：内存取值，寄存器加1，存值到内存。两个或两个以上的原子操作合在一起进行操作就不具备原子性
  - 临界区资源：
    - 在并发情况下，临界区资源是受保护的对象
    - 临界区代码段是每个线程中访问临界资源的那段代码，多个线程必须互斥地对临界区资源进行访问
    - 可以使用synchronized关键字同步代码块，对临界区代码段进行排他性保护

## synchronized关键字

  - 每个Java对象都隐含有一把锁，称为Java内置锁（或对象锁）。使用synchronized(syncObject)调用获取syncObject的内置锁
  - synchronized方法是一种粗粒度的并发控制，某一时刻只能有一个线程执行该synchronized方法；而synchronized代码块是一种细粒度的并发控制，处于synchronized块之外的其他代码是可以被多个线程并发访问的。
  - synchronized方法实际等同于一个synchronized代码块，这个代码块包含同步方法中的所有语句，然后在synchronized代码块的括号中传入this关键字，使用this对象锁作为进入临界区的同步锁
  - 使用synchronized修饰static方法时，synchronized的同步锁不是普通的Object对象的监视锁，而是类对应的Class对象的监视锁

## 生产者-消费者问题

  - 生产者-消费者问题也称有限缓冲问题，关键是：
    - 保证生产者不会在缓冲区满时加入数据，消费者不会在缓冲区空时消费数据
    - 保证生产者加入数据，消费者消费数据过程中，不会产生错误的数据和行为

## Java对象锁结构

  - Java对象结构包括三部分：对象头、对象体和对齐字节
    - 对象头：
      - Mark Word(标记字)：用于存储自身运行时的数据，例如：GC标志位，哈希码，锁状态等
      - Class Pointer(类对象指针)：用于存放方法区Class对象的地址，JVM通过这个指针来确定这个对象是哪个类的实例
      - Array Length(数组长度)：如果对象是Java数组，此字段用于记录数组长度
    - 对象体：包含对象的实例变量
    - 对齐字节：用于保证Java对象所占内存字节数为8的倍数
  - Java内置锁：
    - 4种状态，级别由低到高依次为：无锁、偏向锁、轻量级锁和重量级锁
    - 64位Mark Word结构：
      ![image](https://user-images.githubusercontent.com/46510621/145675162-8dd153e8-6a29-4665-9129-f9bba0056cce.png)
    - 锁状态标志位：
      ![image](https://user-images.githubusercontent.com/46510621/145675214-1c800366-dda1-4f89-a3d9-d4506acbda97.png)

