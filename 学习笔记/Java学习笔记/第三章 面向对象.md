# 面向对象

## 面向过程和面向对象

  - 面向过程强调的是功能行为，以函数为最小单位，考虑怎么做
  - 面向对象是将功能封装进对象，以类/对象为最小单位，考虑谁来做
  
## 类和对象

  - 类和对象是面向对象的核心概念
    - 类是对一类事物的描述
    - 对象是实际存在的该类事物的每个个体，也称为实例
  - Java类和类的成员
    - 属性：对应类中的成员变量
    - 行为：对应类中的成员方法
  - 类的语法格式：
    ```
    修饰符 class 类名 {
      属性声明;
      方法声明;
    }
    ```
    
## 对象的创建和使用

  - 创建对象语法：类名 对象名 = new 类名();
  - 使用对象名.对象成员的方式访问对象成员（包括属性和方法）
  - 类的访问机制：
    - 在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。例外是static方法访问非static编译不通过
    - 在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员
  - 内存解析：
    - 堆：存放对象实例
    - 栈：虚拟机栈用于存储局部变量。方法执行完自动释放
    - 方法区：存储已经被虚拟机加载的类信息，常量，静态变量等数据
    
## 类的属性

  - 语法格式：修饰符 数据类型 属性名 = 初始值;
    - 例如：private int num = 3;
 
## 类的方法

  - 方法的定义：
    - 方法是类或对象行为特征的抽象，用来完成某个功能操作。
    - 将功能封装为方法的目的是，可以实现代码重用，简化代码
  - 方法的声明格式：
    ```
    修饰符 返回值类型 方法名（参数类型 形参1， 参数类型 形参2...）{
      方法体;
      return 返回值;
    }
    ```
  - 方法的调用：
    - 通过方法名调用，且只有被调用时才会执行
  - 方法的重载：
    - 概念：在同一个类中，允许存在多个同名方法，但参数个数或参数类型不同
    - 特点：与返回值类型无关，只看参数列表。调用时根据方法参数列表的不同来区别
  - 可变形参：
    - JDK 1.5提供了Varargs机制，允许直接定义能和多个实参相匹配的形参。
    - 声明格式：方法名（类型 ...参数名）
      - 例如：public void test(int a, String ...books)
    - 说明：
      - 可变参数：参数个数是可变多个：0，1或多个
      - 如果方法参数中有可变形参，需要放在形参声明的最后
  - 方法参数的值传递：
    - 参数分类：
      - 形参：方法声明时的参数
      - 实参：方法调用时实际传给形参的值
    - Java方法的参数传递是通过值传递，即将实际参数值的副本传入方法，而参数本身不受影响
    
## 构造器

  - 特征：
    - 具有与类相同的名称
    - 不声明返回值类型
  - 作用：创建对象，给对象进行初始化
  - 语法格式：
    ```
    修饰符 类名（参数列表）{
      初始化语句;
    }
    ```
  - 分类：
    - 隐式无参构造器（系统默认提供）
    - 显式定义一个或多个构造器（无参，有参）
  - 注意点：
    - Java每个类至少有一个构造器
    - 一旦显式定义了构造器，则系统不再提供默认构造器
    - 父类的构造器不可被子类继承
    
## 关键字-this

  - 定义：
    - 它在方法内部使用，即这个方法所属对象的引用
    - 它在构造器内部使用，表示该构造器正在初始化的对象
  - this可以调用类的属性、方法和构造器
      
## 面向对象特征-封装

  - 封装的思想：
    - 隐藏对象内部的复杂性，只对外公开简单的接口。也符合高内聚，低耦合的设计：
      - 高内聚：类的内部数据操作细节自己完成，不允许外部干涉
      - 低耦合：对外暴露少量的方法
    - 封装的实现方式：
      - 将属性声明为私有的（private），再提供公共的方法：getXxx()和setXxx()对该属性进行操作。
      - 这样做的目的：
        - 隐藏类中不需要对外提供的实现细节
        - 使用者只能通过确定的方法来访问数据，限制对属性的不合理操作
        - 便于修改，增强代码的可维护性
    - 属性的权限修饰符：
      - private：同一个类内有效
      - 缺省：同一个包内有效
      - protected：同一包内，以及不同包的子类有效
      - public：同一个工程有效
        
## 面向对象特征-继承

  - 定义：多个类存在相同属性和行为时，将这些内容抽取到单独一个类中，这些类就无需再定义这些属性和行为，只要继承那个类即可。
    - 子类继承父类，就继承了父类的方法和属性
    - 在子类中可以使用父类定义的方法和属性，也可以创建新的属性和方法
    - 子类不能直接访问父类中私有的属性和方法
    - Java只支持单继承和多层继承，不允许多重继承
  - 类继承语法规则：
    - class SubClass extends SuperClass {}
  - 作用：
    - 减少冗余代码，提高代码的复用性
    - 有利于功能的扩展
    - 让类与类之间产生了关系，提供了多态的前提
    
## 方法的重写

  - 定义：在子类中可以根据需要对从父类中继承来的方法进行改造。程序执行时，子类的方法覆盖父类的方法
  - 要求：
    - 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
    - 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限
      - 子类不能重写父类中声明为private的方法
    - 子类方法抛出的异常不能大于父类被重写方法的异常
    
## 关键字-super

  - super可用于访问父类中的属性和成员方法，在子类构造器中调用父类的构造器
  - 子类所有构造器默认访问父类无参构造器
    
## 面向对象特征-多态

  - 对象的多态性：父类的引用指向子类的对象
  - Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的变量决定，运行时类型由实际赋给该变量的对象决定。简称：编译看左边，运行看右边。
    - 如果编译和运行时类型不一致，就出现了对象的多态性
    - 多态情况下：
      - 看左边是指父类的引用（父类中不具备子类特有的方法）
      - 看右边是指子类的对象（实际运行的是子类重写父类的方法）
    - 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法
  - 多态作用：
    - 提高代码的通用性，常称作接口重用
  - 前提：
    - 存在继承或者实现关系
    - 有方法的重写
  - x instanceof A: 检验x是否为类A的对象，返回值为boolean类型
    
## Object类的使用

  - Object类是所有Java类的根父类
  - 如果在类的声明中未使用extends指明其父类，则默认父类为java.lang.Object类
  
## 包装类的使用

  - 基本数据类型对应的包装类：
    - Byte, Short, Integer, Long, Float, Double, Boolean, Character
  - JDK 1.5之后支持自动装箱，自动拆箱，但类型必须匹配
  - 字符串转换为基本数据类型：
    - Float f = Float.parseFloat("1.23");
  - 基本数据类型转换为字符串：
    - String s = String.valueOf(1.23f);
    
## 关键字-static

  - 类属性作为该类各个对象之间共享的变量，相应的方法设置为类方法
    - 类变量（类属性）由该类所有实例共享
    - 可以用类名.方法名()的形式访问由static修饰的类方法
  - 使用范围：可用static修饰属性、方法、代码块、内部类
  - 被修饰后的成员具备以下特点：
    - 随着类的加载而加载
    - 修饰的成员被所有对象共享
    - 在static方法内部只能访问类的static修饰的属性或方法，不能访问非static修饰的成员
    - static修饰的方法不能被重写
    
## 关键字-final

  - final修饰的类不能被继承
  - final修饰的方法不能被子类重写
  - final修饰的变量即称为常量。名称大写，且只能被赋值一次
  
## 抽象类和抽象方法

  - 定义：
    - 用abstract修饰一个类，则该类为抽象类
    - 用abstract修饰一个方法，则该方法为抽象方法，只有方法的声明，没有方法的实现
    - 含有抽象方法的类必须被声明为抽象类
  - 注意点：
    - 抽象类不能被实例化。它是用于被继承的，子类必须重写父类的抽象方法，并提供方法体。
    - 不能用abstract修饰变量、代码块、构造器
    - 不能用abstract修饰私有方法、静态方法、final的方法、final的类
    
## 接口

  - 定义：
    - 接口就是规范，定义的是一组规则。继承是一个“是不是”的关系，接口实现则是“能不能”的关系
    - 接口是抽象方法和常量值定义的集合
  - 特点：
    - 用interface定义
    - 成员变量默认是由public static final修饰的
    - 抽象方法默认是由public abstract修饰的
    - 接口中没有构造器
    - 接口支持多继承机制
    - 实现接口的类中必须提供接口中所有方法的具体实现内容
    - 与继承关系类似，接口与实现类之间存在多态性
    - 接口可以看作一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现
  
## 内部类

  - 在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。Inner class一般用于定义它的类或语句块内，在外部引用时必须给出完整的名称
  - 分类：
    - 成员内部类
    - 局部内部类
    
    
    
