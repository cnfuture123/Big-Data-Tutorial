## 对象回收判断方式

  - 引用计数算法：
    - 定义：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一;当引用失效时，计数器值就减一;任何时刻计数器为零的对象就是不可能再被使用的
    - 主流的Java虚拟机里面都没有选用引用计数算法来管理内存，原因是这个看似简单的算法必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题
  - 可达性分析算法：
    - 这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的
    - 固定可作为GC Roots的对象包括以下几种:
      - 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
      - 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
      - 在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用
      - 所有被同步锁(synchronized关键字)持有的对象
  - 要真正宣告一个对象死亡，至少要经历两次标记过程:
    - 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法
    - 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法
    - 如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合

## 引用分类

  - 将对象引用分为强引用、软引用、弱引用和虚引用4种：
    - 强引用是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象
    - 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收
    - 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止
    - 虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知
  
## 回收方法区

  - 方法区的垃圾收集主要回收两部分内容:废弃的常量和不再使用的类型

## 垃圾收集算法

  - 分代收集理论：
    - 建立在两个分代假说之上:
      - 弱分代假说(Weak Generational Hypothesis): 绝大多数对象都是朝生夕灭的
      - 强分代假说(Strong Generational Hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡
    - 把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域
  - 回收类型：
    - 新生代收集(Minor GC/Young GC): 指目标只是新生代的垃圾收集
    - 老年代收集(Major GC/Old GC): 指目标只是老年代的垃圾收集
    - 混合收集(Mixed GC): 指目标是收集整个新生代以及部分老年代的垃圾收集
    - 整堆收集(Full GC): 收集整个Java堆和方法区的垃圾收集
  - 垃圾收集算法：
    - 标记-清除算法：
      - 算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象
      - 主要缺点：
        - 第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低
        - 第二个是内存空间的碎片化问题，清除之后会产生大量不连续的内存碎片，可能会导致在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
    - 标记-复制算法：
      - 半区复制垃圾收集算法：
        - 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉
        - 这种复制回收算法的代价是将可用内存缩小为了原来的一半，造成空间浪费
      - Appel式回收：
        - 一种更优化的半区复制分代策略，Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局
        - 具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间
        - HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%
    - 标记-整理算法：
      - 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存

## 垃圾回收器

  - Serial收集器:
    - Serial收集器是HotSpot虚拟机新生代收集器，这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束
    - 迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的
    - 示意图：
      
      <img width="1064" alt="image" src="https://user-images.githubusercontent.com/46510621/159110334-9280c0e9-54e6-442a-91ae-c82f20ec1ad6.png">

  - ParNew收集器：
    - ParNew收集器实质上是Serial收集器的多线程并行版本
    - 示意图：

      <img width="1064" alt="image" src="https://user-images.githubusercontent.com/46510621/159110474-29485154-a133-41d7-b5e0-cd248b874ef3.png">

    - 自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案，官方希望它能完全被G1所取代
  - Parallel Scavenge收集器：
    - Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器
    - Parallel Scavenge收集器的关注点与其他收集器不同，CM 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值
  - Serial Old收集器：
    - Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用
  - Parallel Old收集器：
    - Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现
  - CMS收集器：
    - CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求
    - CMS收集器是基于标记-清除算法实现的，整个过程分为四个步骤：
      - 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
      - 并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
      - 重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
      - 并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的
      - 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”
    - CMS优缺点：
      - 优点：并发收集、低停顿
      - 缺点：
        - CMS收集器对处理器资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢，降低总吞吐量
        - CMS是一款基于“标记-清除”算法实现的收集器，会有大量空间碎片产生
  - Garbage First收集器：
    - 概述：
      - Garbage First(简称G1)收集器，开创了面向局部收集的设计思路和基于Region的内存布局形式
      - G1是一款主要面向服务端应用的垃圾收集器
    - 回收原理：
      - G1开创的基于Region的堆内存布局，G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间
      - 每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围为1MB~32MB，且应为2的N次幂
      - G1收集器建立可预测的停顿时间模型：
        - 它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集
        - G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间(使用参数-XX:MaxGCPauseMillis指定，默认值是200毫秒)，优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来
    - G1收集器的运作过程大致可划分为以下四个步骤:
      - 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象
      - 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象
      - 最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录
      - 筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间
    - G1优缺点：
      - 收集器目标是在延迟可控的情况下获得尽可能高的吞吐量
      - 优点：
        - 可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集这些创新性设计带来的红利
        - G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存
      - 缺点：
        - 在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高
  - 低延迟垃圾收集器：
    - 衡量垃圾收集器的三项最重要的指标是:内存占用(Footprint)、吞吐量(Throughput)和延迟(Latency)，三者共同构成了一个不可能三角
    - 最后的两款收集器：Shenandoah和ZGC，几乎整个过程都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿

## 选择合适的垃圾收集器

  - 收集器的选择主要受以下三个因素影响: 
    - 应用程序的主要关注点是什么：吞吐量，延迟，内存占用
    - 运行应用的基础设施如何：硬件规格，处理器的数量多少，分配内存的大小，选择的操作系统是Linux、Solaris还是Windows
    - 使用JDK的发行商是什么，版本号是多少

## 内存分配与回收策略

  - Java技术体系的自动内存管理，最根本的目标是解决两个问题: 自动给对象分配内存以及自动回收分配给对象的内存
  - 对象优先在Eden分配：
    - 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC
    - HotSpot虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况
  - 大对象直接进入老年代：
    - 大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组
    - HotSpot虚拟机提供了-XX:PretenureSizeThreshold参数，指定大于该值的对象直接在老年代分配，目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作
  - 长期存活的对象将进入老年代：
    - 对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被晋升到老年代中
    - 对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置


