# 多线程

## 基本概念

  - 程序：存放在硬盘中的可执行文件，主要包括代码指令和数据
  - 进程：一个进程是一个程序的一次启动和执行，是操作系统将程序装入内存，给程序分配必要的系统资源，并且开始运行程序的指令
    - 程序是静态的，进程是动态的
    - 进程是操作系统分配资源的最小单位，系统在运行时会为每个进程分配不同的内存区域
    - 通常一个进程由程序段，数据段和进程控制块三部分组成
      - 程序段也被称为代码段，代码段是进程的程序指令在内存中的位置，包含需要执行的指令集合
      - 数据段是进程的操作数据在内存中的位置，包含需要操作的数据集合
      - 程序控制块（Program Control Block, PCB）：包含进程的描述信息和控制信息，是进程的唯一标识
  - CPU是核心的硬件资源，承担了所有的计算任务；内存承担了运行时数据的保存任务；外存资源（硬盘等）承担了数据外部存储的任务
  - 线程：
    - 线程是进程代码段的一次顺序执行流程，是CPU调度和执行任务的最小单位
    - 一个进程可以有一个或多个线程，各线程共享进程的内存空间、系统资源
    - 线程主要由三部分组成：线程描述信息、程序计数器和栈内存
      - 线程描述信息：线程ID，线程名称，线程优先级，线程状态
      - 程序计数器记录线程下一条指令的代码段内存地址
      - 栈内存是代码段中局部变量的存储空间，为线程独有
    - 方法的执行：
      - 每一次执行都会分配一个栈帧，栈帧用来保存该方法的局部变量、方法的返回地址以及其他方法相关信息
      - 当线程执行该方法时，JVM会分配一个栈帧压入栈内存；方法执行完成时弹出该方法的栈帧，此时栈帧的局部变量的内存空间会被回收
    - 守护线程是在进程运行时提供某种后台服务的线程，比如垃圾回收线程
  - 并行与并发：
    - 并行：多个CPU同时执行多个任务
    - 并发：一个CPU（时间片内）同时执行多个任务
  - 多线程的优点：
    - 提高CPU的利用率
    - 提高应用程序的响应
    
## 线程的创建和使用

  - Thread类：
    - 每个线程通过特定Thread对象的run()完成操作，通常把run()的主体称为线程体
    - 调用Thread对象的start()启动线程，不是调用run()
  - 创建线程的方式：
    - 继承Thread类：
      - 定义子类继承Thread类
      - 子类重写Thread类的run()
      - 创建子类对象，即创建了线程对象
      - 调用start()启动线程
      - 示例：
        ```
        // 创建线程类
        public class MyThread extends Thread {
          public void run() {
            System.out.println("MyThread run.");
          }
        }
        // 启动线程
        MyThread thread1 = new MyThread();
        thread1.start();
        ```
    - 实现Runnable接口：
      - 定义子类，实现Runnable接口
      - 子类重写Runnable接口的run()，实现代码逻辑
      - 通过Thread类有参构造器创建线程对象
      - 将子类对象作为实际参数传递给Thread类的构造器
        ```
        public Thread(Runnable target)
        public Thread(Runnable target, String name)
        ```
      - 调用Thread类的start()启动线程
      - Runnable接口是一个函数式接口，有且仅有一个抽象方法的接口
      - 示例：
        ```
        public class MyThread implements Runnable {
          public void run() {
            System.out.println("MyThread run.");
          }
        }
        
        MyThread thread2 = new MyThread();
        Thread thread = new Thread(thread2);
        thread.start();
        ```
    - 实现Callable接口：与Runnable接口相比，功能更强大
      - 可以有返回值
      - 可以抛出异常
      - 需要借助FutureTask类获取返回结果
      - 示例：
        ```
        // 创建线程类
        public class ExecutorTask implements Callable<List<String>> {
          public List<String> call() {
            List<String> res = new ArrayList();
            ...
            return res;
          }
        }
        // 多线程执行任务
        public List<String> handleMultiTasks() {
          ExecutorService executorService = Executors.newFixedThreadPool(100);
          List<ExecutorTask> taskList = new ArrayList<>();
          taskList.add(new ExecutorTask());
          List<Future<List<String>>> futures = excutorService.invokeAll(taskList);
          
          List<String> res = new ArrayList<>();
          for (Future future : futures) {
            List<String> items = (List<String>) future.get();
            res.addAll(items);
          }
          return res;
        }
        ```
    - 使用线程池：
      - 提前创建多个线程，放入线程池。使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用
      - 相关API：ExecutorService和Executors
        - ExecutorService是线程池接口，常见子类是ThreadPoolExecutor
          - execute(Runnable command)：执行任务，没有返回值，一般用来执行Runnable
          - submit(Callable<T> task)：执行任务，有返回值，一般用来执行Callable
          - shutdown()：关闭连接池
        - Executors：线程池的工厂类，用于创建并返回不同类型的线程池
          - Executors.newCachedThreadPool()：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。
          - Executors.newFixedThreadPool(n)：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。
          - Executors.newSingleThreadExecutor()：创建一个单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
          - Executors.newScheduledThreadPool(n)：创建一个周期性的线程池，支持定时及周期性执行任务。
        - 通过ThreadPoolExecutor类自定义线程池：
          - ThreadPoolExecutor类提供了4种构造方法：
            ```
            public ThreadPoolExecutor(
              int corePoolSize,
              int maximumPoolSize,
              long keepAliveTime,
              TimeUnit unit,
              BlockingQueue<Runnable> workQueue,
              ThreadFactory threadFactory,
              RejectedExecutionHandler handler
            ) {...}
  
            示例：
            ThreadPoolExecutor executor = new ThreadPoolExecutor(
              this.threadPoolCoreSize,
              this.threadPoolMaxSize,
              this.keepAliveTime,
              TimeUnit.SECONDS,
              new SynchronousQueue<>(true),
              new ThreadFactory() {
                private final AtomicInteger threadNum = new AtomicInteger(1);
                public Thread newThread(Runnable r) {
                  return new Thread(null, r, "key" + threadNum.getAndIncrement(), 0);
                }
              }
            );
            ```
          - 包含7个参数：
            - corePoolSize：核心线程数，线程池中始终存活的线程数
            - maximumPoolSize: 最大线程数，线程池中允许的最大线程数
            - keepAliveTime: 存活时间，线程没有任务执行时最多保持多久时间会终止
            - unit: 单位，参数keepAliveTime的时间单位，7种可选。
            - workQueue: 一个阻塞队列，用来存储等待执行的任务，均为线程安全，7种可选。
            - threadFactory: 线程工厂，主要用来创建线程
            - handler：拒绝策略，拒绝处理任务时的策略，4种可选，默认为AbortPolicy。
              - AbortPolicy：拒绝并抛出异常
              - CallerRunsPolicy：重试提交当前的任务，即再次调用运行该任务的execute()方法
              - DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务
              - DiscardPolicy：抛弃当前任务
          - 线程池的执行规则：
            - 当线程数小于核心线程数时，创建线程
            - 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列
            - 当线程数大于等于核心线程数，且任务队列已满：
              - 若线程数小于最大线程数，创建线程
              - 若线程数等于最大线程数，执行拒绝策略
          - 阿里代码规范中明确不建议使用Executors类提供的这4种方法，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
            - FixedThreadPool和SingleThreadPool：允许的阻塞队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。
            - CachedThreadPool和ScheduledThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。
    - Thread类相关方法：
      - start()：启动线程，JVM会开启一个新线程来执行用户定义的线程代码逻辑
      - run()：作为线程代码逻辑的入口方法，当调用start()方法启动一个线程后，只要线程获得了CPU执行时间，便进入run()方法体去执行具体的用户线程代码
      - currentThread()：获取当前线程的Thread实例对象
      - yield()：线程让步
        - 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
      - join()：当某个线程执行过程中调用其它线程的join()，调用线程将被阻塞，直到join的线程执行完为止
      - sleep()：当前线程在指定时间段内休眠
      - stop()：强制线程生命周期结束，不推荐使用
      - isAlive()：判断线程是否活着
    - 线程的调度：
      - 同优先级线程组成FIFO队列，使用时间片策略
      - 高优先级的线程使用优先调度的抢占式策略，优先使用CPU
    - 线程的优先级：
      - 由低到高：
        - MIN_PRIORITY: 1
        - NORM_PRIORITY: 5
        - MAX_PRIORITY: 10
      - 涉及的方法：
        - getPriority()：返回线程的优先值
        - setPriority(int val)：改变线程的优先级
      - 说明：
        - 线程创建时继承父线程的优先级
        - 低优先级只是获得调度的概率低，并不一定在高优先级线程之后被调用
        
## 线程的生命周期

  - 五种状态：
    - 新建：当一个Thread类或其子类的对象被声明并创建时，处于新建状态
    - 就绪：新建状态的线程调用start()，将进入线程队列等待CPU时间片，此时具备了运行的条件，只是没分配到资源
    - 运行：就绪的线程被调度并获得CPU资源，调用run()实现线程的操作和功能
    - 阻塞：人为挂起或执行IO操作时，让出CPU并临时终止执行，进入阻塞状态
    - 等待：WAITING
    - 计时等待：TIMED_WAITING
    - 死亡：线程完成全部工作，或线程提前强制性的终止，或出现异常导致结束
        
## 线程同步

  - Synchronized使用方法：
    - 同步代码块：
      ```
      synchronized(Object) {
        需要同步的代码块;
      }
      ```
    - 同步方法：
      ```
      public synchronized void show(String name) {
        方法体;
      }
      ```
  - 同步机制中的锁：
    - 任意对象都可以作为同步锁，所有对象都自动含有单一的锁
    - 同步方法的锁：静态方法（类名.class），非静态方法（this）
    - 同步代码块：自己指定
    - 必须确保使用同一个资源的多个线程共用一把锁，否则无法保证共享资源的安全
  - 释放锁的操作：
    - 当前线程的同步方法、同步代码块执行结束
    - 当前线程在同步方法、同步代码块中遇到break, return终止执行
    - 当前线程在同步方法、同步代码块中出现了未处理的Error或Exception
    - 当前线程在同步方法、同步代码块中执行了线程对象的wait()，当前线程暂停，并释放锁
  - Lock锁：
    - JDK 1.5开始，通过显式定义同步锁对象实现同步，同步锁对象使用Lock对象
    - java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。线程开始访问资源之前应先获得Lock对象，每次只能有一个线程对Lock对象加锁
    - ReentrantLock类实现了Lock，与synchronized有相同的并发性和内存语义，它可以显示加锁、释放锁。
      - 可重入锁表示当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然会导致锁不被释放。

        ![image](https://user-images.githubusercontent.com/46510621/114145190-bcd98880-9948-11eb-9cca-a191e172a34b.png)
      
  - synchronized和Lock对比：
    - Synchronized是关键字，Lock是接口。
    - Lock是可中断锁，可以手动开启和关闭锁；Synchronized是非中断锁，必须等待线程执行完成释放锁。
    - Lock可以使用读锁提高多线程读效率。
    - 优先使用顺序：Lock > 同步代码块 > 同步方法
    
## 线程的通信

  - wait(), notify(), notifyAll()：
    - wait()：当前线程挂起并放弃CPU资源，进入等待状态。需要调用notify()或notifyAll()唤醒
    - notify()：唤醒正在排队等待资源的线程中优先级最高的
    - notifyAll()：唤醒正在排队等待资源的所有线程
    
