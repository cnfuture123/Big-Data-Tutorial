## 高并发的必备技能

  - Netty:
    - 概述：
      - Netty是JBOSS提供的一个Java开源框架，是基于NIO的客户端/服务端编程框架，NIO(Non-Blocking IO)是指非阻塞IO
      - 提供异步的、事件驱动的网络应用程序框架和工具
    - Netty优点：
      - API使用简单，开发门槛低
      - 功能强大，预置多种编解码功能，支持多种主流协议
      - 定制能力强，可以通过ChannelHandle对通信框架进行灵活扩展
      - 性能高
      - 社区活跃
  - Redis：
    - 主要应用场景：
      - 缓存：数据查询、短连接、新闻内容
      - 分布式会话
      - 任务队列：秒杀、抢购
      - 应用排行榜
      - 数据过期处理
  - ZooKeeper:
    - ZooKeeper是重要的分布式协调工具
  - 高性能HTTP通信技术：
    - 十万级QPS的Web应用框架图：
      
      <img width="771" alt="image" src="https://user-images.githubusercontent.com/46510621/156917658-510d2e66-dc81-4c8e-b5a2-3a6fd0f44180.png">

      - 对于十万级流量的系统应用，其架构一般可以分为三层：服务层、接入层、客户端层
        - 服务层一般执行的是Java应用程序，可以细分为传统的单体应用和Spring Cloud分布式应用
        - 接入层主要完成鉴权、限流、反向代理和负载均衡等功能，一般是使用Nginx + Lua作为接入服务器。为了保证高可用，会搭建冗余的接入服务器，然后使用KeepAlived中间件进行高可用监控管理，并且虚拟出外部IP，供外部访问
    - 千万级QPS的Web应用框架图：

      <img width="743" alt="image" src="https://user-images.githubusercontent.com/46510621/156917992-b670530e-c95c-4f51-971c-2a6b36f3a3e4.png">

      - 对于千万级QPS的Web应用，除了服务层的独立Tomcat或Spring Cloud微服务节点需要不断的横向扩展外，还需要进行以下两大增强：
        - 引入LVS负载均衡层，进行请求分发和接入层的负载均衡
        - 引入DNS服务器的负载均衡，可以在域名下面添加多个IP，由DNS服务器进行多个IP之间的负载均衡

## 高并发IO的底层

  - IO读写的基本原理：
    - 概述：
      - 操作系统将内存划分为两部分：一部分是内核空间(Kernel-Space)，另一部分是用户空间(User-Space)。在Linux系统中，内核模块运行在内核空间，对应的进程处于内核态；用户程序运行在用户空间，对应的进程处于用户态
      - 用户态进程必须通过系统调用向内核发出指令，完成调用系统资源的操作
    - IO读写流程：
      - 上层应用通过操作系统的read系统调用把数据从内核缓冲区复制到应用程序的进程缓冲区，通过操作系统的write系统调用把数据应用程序的进程缓冲区复制到操作系统的内核缓冲区。应用程序的IO操作实际上不是物理设备的读写，而是缓存的复制
    - Java客户端和服务端完成一次socket请求与响应的数据交换流程：
      - 客户端发送请求：Java客户端程序通过write系统调用将数据复制到内核缓冲区，Linux将内核缓冲区的请求数据通过客户端机器的网卡发送出去。在服务端，请求数据从接收网卡读到服务器机器的内核缓冲区
      - 服务端获取请求：Java服务端程序通过read系统调用从Linux内核缓冲区读取数据，再送入Java进程缓冲区
      - 服务端业务处理：Java服务端在自己的用户空间中完成客户端请求对应的业务处理
      - 服务端返回数据：Java服务端完成处理后，构建好的响应数据从用户缓冲区写入内核缓冲区，操作系统负责将内核缓冲区的数据发送出去
      - 发送给客户端：服务端Linux系统将内核缓冲区的数据写入网卡，网卡通过底层的通信协议将数据发送给目标客户端
  - 四种主要的IO模型：
    - 同步阻塞IO：
      - 同步阻塞IO指的是指的是用户空间主动发起，需要等待内核IO操作完成后才返回到用户空间的IO操作。在IO操作过程中，发起IO请求的用户进程处于阻塞状态
      - 阻塞IO的优缺点：
        - 优点：应用程序开发简单，在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源
        - 缺点：一般情况每个连接配备一个独立的线程，一个线程维护一个连接的IO操作。在高并发的应用场景下，阻塞IO需要大量的线程来维护大量的网络连接，内存、线程切换开销非常大z
    - 同步非阻塞IO：
      - 同步非阻塞IO指的是用户进程主动发起，不需要等待内核IO操作完成就能立即返回用户空间的IO操作。在IO操作过程中，发起IO请求的用户进程处于非阻塞状态
      - 应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好就继续轮询，直到完成IO系统调用为止
    - IO多路复用：
      - 在Linux中，select/epoll系统调用可以用于监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程，用户空间根据文件描述符的就绪状态进行相应的IO系统调用
      - 采用IO多路复用模型可以避免同步非阻塞IO轮询等待的问题，通过select/epoll系统调用，单个应用程序的线程可以不断的轮询成百上千的socket连接的就绪状态并返回
      - Java的NIO组件在Linux系统上使用epoll系统调用实现的，使用的就是IO多路复用模型
    - 异步IO：
      - 用户线程通过系统调用向内核注册某个IO操作，内核在整个IO操作（包括数据准备、数据复制）完成后通知用户程序，用户执行后续的业务操作。在整个内核的数据处理过程，用户程序都不需要阻塞

## Java NIO

  - 概述：
    
      
        
      
    
    
